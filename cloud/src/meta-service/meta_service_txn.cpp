#include <chrono>

#include "common/logging.h"
#include "common/sync_point.h"
#include "meta-service/doris_txn.h"
#include "meta-service/meta_service.h"
#include "meta-service/meta_service_helper.h"
#include "meta-service/meta_service_tablet_stats.h"

using namespace std::chrono;

namespace selectdb {

//TODO: we need move begin/commit etc txn to TxnManager
void MetaServiceImpl::begin_txn(::google::protobuf::RpcController* controller,
                                const ::selectdb::BeginTxnRequest* request,
                                ::selectdb::BeginTxnResponse* response,
                                ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(begin_txn);
    if (!request->has_txn_info()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "invalid argument, missing txn info";
        return;
    }

    auto& txn_info = const_cast<TxnInfoPB&>(request->txn_info());
    std::string label = txn_info.has_label() ? txn_info.label() : "";
    int64_t db_id = txn_info.has_db_id() ? txn_info.db_id() : -1;

    if (label.empty() || db_id < 0 || txn_info.table_ids().empty() || !txn_info.has_timeout_ms()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "invalid argument, label=" << label << " db_id=" << db_id;
        msg = ss.str();
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id) << " label=" << label;
        msg = ss.str();
        return;
    }

    RPC_RATE_LIMIT(begin_txn)
    //1. Generate version stamp for txn id
    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        ss << "txn_kv_->create_txn() failed, ret=" << ret << " label=" << label
           << " db_id=" << db_id;
        msg = ss.str();
        return;
    }

    std::string txn_label_key_;
    std::string txn_label_val;

    TxnLabelKeyInfo txn_label_key_info {instance_id, db_id, label};
    txn_label_key(txn_label_key_info, &txn_label_key_);

    ret = txn->get(txn_label_key_, &txn_label_val);
    if (ret < 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "txn->get failed(), ret=" << ret << " label=" << label;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "txn->get txn_label_key=" << hex(txn_label_key_) << " label=" << label
              << " ret=" << ret;

    //ret == 0 means label has previous txn ids.
    if (ret == 0) {
        txn_label_val = txn_label_val.substr(0, txn_label_val.size() - VERSION_STAMP_LEN);
    }

    //ret > 0, means label not exist previously.
    txn->atomic_set_ver_value(txn_label_key_, txn_label_val);
    LOG(INFO) << "txn->atomic_set_ver_value txn_label_key=" << hex(txn_label_key_);

    TEST_SYNC_POINT_CALLBACK("begin_txn:before:commit_txn:1", &label);
    ret = txn->commit();
    TEST_SYNC_POINT_CALLBACK("begin_txn:after:commit_txn:1", &label);
    if (ret != 0) {
        code = ret == -1 ? MetaServiceCode::KV_TXN_CONFLICT : MetaServiceCode::KV_TXN_COMMIT_ERR;
        ss << "txn->commit failed(), label=" << label << " ret=" << ret;
        msg = ss.str();
        return;
    }
    //2. Get txn id from version stamp
    txn.reset();

    txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        ss << "failed to create txn when get txn id, label=" << label << " ret=" << ret;
        msg = ss.str();
        return;
    }

    txn_label_val.clear();
    ret = txn->get(txn_label_key_, &txn_label_val);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "txn->get() failed, label=" << label << " ret=" << ret;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "txn->get txn_label_key=" << hex(txn_label_key_) << " label=" << label
              << " ret=" << ret;

    std::string txn_id_str =
            txn_label_val.substr(txn_label_val.size() - VERSION_STAMP_LEN, txn_label_val.size());
    // Generated by TxnKv system
    int64_t txn_id = 0;
    ret = get_txn_id_from_fdb_ts(txn_id_str, &txn_id);
    if (ret != 0) {
        code = MetaServiceCode::TXN_GEN_ID_ERR;
        ss << "get_txn_id_from_fdb_ts() failed, label=" << label << " ret=" << ret;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "get_txn_id_from_fdb_ts() label=" << label << " txn_id=" << txn_id
              << " txn_label_val.size()=" << txn_label_val.size();

    TxnLabelPB txn_label_pb;
    if (txn_label_val.size() > VERSION_STAMP_LEN) {
        //3. Check label
        //txn_label_val.size() > VERSION_STAMP_LEN means label has previous txn ids.

        std::string txn_label_pb_str =
                txn_label_val.substr(0, txn_label_val.size() - VERSION_STAMP_LEN);
        if (!txn_label_pb.ParseFromString(txn_label_pb_str)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "txn_label_pb->ParseFromString() failed, txn_id=" << txn_id << " label=" << label;
            msg = ss.str();
            return;
        }

        // Check if label already used, by following steps
        // 1. get all existing transactions
        // 2. if there is a PREPARE transaction, check if this is a retry request.
        // 3. if there is a non-aborted transaction, throw label already used exception.

        for (auto& cur_txn_id : txn_label_pb.txn_ids()) {
            std::string cur_txn_inf_key;
            std::string cur_txn_inf_val;
            TxnInfoKeyInfo cur_txn_inf_key_info {instance_id, db_id, cur_txn_id};
            txn_info_key(cur_txn_inf_key_info, &cur_txn_inf_key);
            ret = txn->get(cur_txn_inf_key, &cur_txn_inf_val);
            if (ret < 0) {
                code = MetaServiceCode::KV_TXN_GET_ERR;
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " label=" << label
                   << " ret=" << ret;
                msg = ss.str();
                return;
            }

            if (ret == 1) {
                //label_to_idx and txn info inconsistency.
                code = MetaServiceCode::TXN_ID_NOT_FOUND;
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " label=" << label
                   << " ret=" << ret;
                msg = ss.str();
                return;
            }

            TxnInfoPB cur_txn_info;
            if (!cur_txn_info.ParseFromString(cur_txn_inf_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "cur_txn_info->ParseFromString() failed, cur_txn_id=" << cur_txn_id
                   << " label=" << label << " ret=" << ret;
                msg = ss.str();
                return;
            }

            VLOG_DEBUG << "cur_txn_info=" << cur_txn_info.ShortDebugString();
            if (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
                continue;
            }

            if (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PREPARED ||
                cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PRECOMMITTED) {
                // clang-format off
                if (cur_txn_info.has_request_id() && txn_info.has_request_id() &&
                    ((cur_txn_info.request_id().hi() == txn_info.request_id().hi()) && 
                     (cur_txn_info.request_id().lo() == txn_info.request_id().lo()))) {

                    response->set_dup_txn_id(cur_txn_info.txn_id());
                    code = MetaServiceCode::TXN_DUPLICATED_REQ;
                    ss << "db_id=" << db_id << " label=" << label << " txn_id=" << cur_txn_info.txn_id() << " dup begin txn request.";
                    msg = ss.str();
                    return;
                }
                // clang-format on
            }
            code = MetaServiceCode::TXN_LABEL_ALREADY_USED;
            ss << "db_id=" << db_id << " label=" << label
               << " already used by txn_id=" << cur_txn_info.txn_id();
            msg = ss.str();
            return;
        }
    }

    // Update txn_info to be put into TxnKv
    // Update txn_id in PB
    txn_info.set_txn_id(txn_id);
    // TODO:
    // check initial status must be TXN_STATUS_PREPARED or TXN_STATUS_UNKNOWN
    txn_info.set_status(TxnStatusPB::TXN_STATUS_PREPARED);

    auto now_time = system_clock::now();
    uint64_t prepare_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();

    txn_info.set_prepare_time(prepare_time);
    //4. put txn info and db_tbl
    std::string txn_inf_key;
    std::string txn_inf_val;
    TxnInfoKeyInfo txn_inf_key_info {instance_id, db_id, txn_id};
    txn_info_key(txn_inf_key_info, &txn_inf_key);
    if (!txn_info.SerializeToString(&txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_info, label=" << label << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    std::string txn_index_key_;
    std::string txn_index_val;
    TxnIndexKeyInfo txn_index_key_info {instance_id, txn_id};
    txn_index_key(txn_index_key_info, &txn_index_key_);
    TxnIndexPB txn_index_pb;
    txn_index_pb.mutable_tablet_index()->set_db_id(db_id);
    if (!txn_index_pb.SerializeToString(&txn_index_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_index_pb "
           << "label=" << label << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    std::string txn_run_key;
    std::string txn_run_val;
    TxnRunningKeyInfo txn_run_key_info {instance_id, db_id, txn_id};
    txn_running_key(txn_run_key_info, &txn_run_key);

    TxnRunningPB running_val_pb;
    running_val_pb.set_timeout_time(prepare_time + txn_info.timeout_ms());
    for (auto i : txn_info.table_ids()) {
        running_val_pb.add_table_ids(i);
    }
    VLOG_DEBUG << "label=" << label << " txn_id=" << txn_id
               << "running_val_pb=" << running_val_pb.ShortDebugString();
    if (!running_val_pb.SerializeToString(&txn_run_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize running_val_pb label=" << label << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    txn_label_pb.add_txn_ids(txn_id);
    VLOG_DEBUG << "label=" << label << " txn_id=" << txn_id
               << "txn_label_pb=" << txn_label_pb.ShortDebugString();
    if (!txn_label_pb.SerializeToString(&txn_label_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_label_pb label=" << label << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    txn->atomic_set_ver_value(txn_label_key_, txn_label_val);
    LOG(INFO) << "txn->atomic_set_ver_value txn_label_key=" << hex(txn_label_key_)
              << " label=" << label << " txn_id=" << txn_id;

    txn->put(txn_inf_key, txn_inf_val);
    txn->put(txn_index_key_, txn_index_val);
    txn->put(txn_run_key, txn_run_val);
    LOG(INFO) << "xxx put txn_info_key=" << hex(txn_inf_key) << " txn_id=" << txn_id;
    LOG(INFO) << "xxx put txn_run_key=" << hex(txn_run_key) << " txn_id=" << txn_id;
    LOG(INFO) << "xxx put txn_index_key=" << hex(txn_index_key_) << " txn_id=" << txn_id;

    ret = txn->commit();
    if (ret != 0) {
        code = ret == -1 ? MetaServiceCode::KV_TXN_CONFLICT : MetaServiceCode::KV_TXN_COMMIT_ERR;
        ss << "failed to commit txn kv, label=" << label << " txn_id=" << txn_id << " ret=" << ret;
        msg = ss.str();
        return;
    }
    TEST_SYNC_POINT_CALLBACK("begin_txn:after:commit_txn:2", &txn_id);
    response->set_txn_id(txn_id);
}

void MetaServiceImpl::precommit_txn(::google::protobuf::RpcController* controller,
                                    const ::selectdb::PrecommitTxnRequest* request,
                                    ::selectdb::PrecommitTxnResponse* response,
                                    ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(precommit_txn);
    int64_t txn_id = request->has_txn_id() ? request->txn_id() : -1;
    int64_t db_id = request->has_db_id() ? request->db_id() : -1;
    if ((txn_id < 0 && db_id < 0)) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "invalid argument, "
           << "txn_id=" << txn_id << " db_id=" << db_id;
        msg = ss.str();
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id) << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    RPC_RATE_LIMIT(precommit_txn);
    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        ss << "txn_kv_->create_txn() failed, ret=" << ret << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    //not provide db_id, we need read from disk.
    if (db_id < 0) {
        std::string txn_index_key_;
        std::string txn_index_val;
        TxnIndexKeyInfo txn_index_key_info {instance_id, txn_id};
        txn_index_key(txn_index_key_info, &txn_index_key_);
        ret = txn->get(txn_index_key_, &txn_index_val);
        if (ret != 0) {
            code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND : MetaServiceCode::KV_TXN_GET_ERR;
            ss << "failed to get db id with txn_id=" << txn_id << " ret=" << ret;
            msg = ss.str();
            return;
        }
        TxnIndexPB txn_index_pb;
        if (!txn_index_pb.ParseFromString(txn_index_val)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "failed to parse txn_inf"
               << " txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        DCHECK(txn_index_pb.has_tablet_index() == true);
        DCHECK(txn_index_pb.tablet_index().has_db_id() == true);
        db_id = txn_index_pb.tablet_index().db_id();
        VLOG_DEBUG << " find db_id=" << db_id << " from index";
    } else {
        db_id = request->db_id();
    }

    // Get txn info with db_id and txn_id
    std::string txn_inf_key; // Will be used when saving updated txn
    std::string txn_inf_val; // Will be reused when saving updated txn
    TxnInfoKeyInfo txn_inf_key_info {instance_id, db_id, txn_id};
    txn_info_key(txn_inf_key_info, &txn_inf_key);
    ret = txn->get(txn_inf_key, &txn_inf_val);
    if (ret != 0) {
        code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND : MetaServiceCode::KV_TXN_GET_ERR;
        ss << "failed to get db id with db_id=" << db_id << " txn_id=" << txn_id << " ret=" << ret;
        msg = ss.str();
        return;
    }

    TxnInfoPB txn_info;
    if (!txn_info.ParseFromString(txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_inf db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    DCHECK(txn_info.txn_id() == txn_id);
    if (txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
        code = MetaServiceCode::TXN_ALREADY_ABORTED;
        ss << "transaction is already aborted: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    if (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE) {
        code = MetaServiceCode::TXN_ALREADY_VISIBLE;
        ss << "ransaction is already visible: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
    }

    if (txn_info.status() == TxnStatusPB::TXN_STATUS_PRECOMMITTED) {
        code = MetaServiceCode::TXN_ALREADY_PRECOMMITED;
        ss << "ransaction is already precommited: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
    }

    LOG(INFO) << "before update txn_info=" << txn_info.ShortDebugString();

    // Update txn_info
    txn_info.set_status(TxnStatusPB::TXN_STATUS_PRECOMMITTED);

    auto now_time = system_clock::now();
    uint64_t precommit_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();
    txn_info.set_precommit_time(precommit_time);
    if (request->has_commit_attachment()) {
        txn_info.mutable_commit_attachment()->CopyFrom(request->commit_attachment());
    }
    LOG(INFO) << "after update txn_info=" << txn_info.ShortDebugString();

    txn_inf_val.clear();
    if (!txn_info.SerializeToString(&txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_info when saving, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "xxx put txn_inf_key=" << hex(txn_inf_key) << " txn_id=" << txn_id;
    txn->put(txn_inf_key, txn_inf_val);

    std::string txn_run_key;
    std::string txn_run_val;
    TxnRunningKeyInfo txn_run_key_info {instance_id, db_id, txn_id};
    txn_running_key(txn_run_key_info, &txn_run_key);

    TxnRunningPB running_val_pb;
    running_val_pb.set_timeout_time(precommit_time + txn_info.precommit_timeout_ms());
    if (!running_val_pb.SerializeToString(&txn_run_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize running_val_pb, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "xxx put txn_run_key=" << hex(txn_run_key) << " txn_id=" << txn_id;
    txn->put(txn_run_key, txn_run_val);

    ret = txn->commit();
    if (ret != 0) {
        code = ret == -1 ? MetaServiceCode::KV_TXN_CONFLICT : MetaServiceCode::KV_TXN_COMMIT_ERR;
        ss << "failed to commit txn kv, txn_id=" << txn_id << " ret=" << ret;
        msg = ss.str();
        return;
    }
}

/**
 * 0. Extract txn_id from request
 * 1. Get db id from TxnKv with txn_id
 * 2. Get TxnInfo from TxnKv with db_id and txn_id
 * 3. Get tmp rowset meta, there may be several or hundred of tmp rowsets
 * 4. Get versions of each rowset
 * 5. Put rowset meta, which will be visible to user
 * 6. Put TxnInfo back into TxnKv with updated txn status (committed)
 * 7. Update versions of each partition
 * 8. Remove tmp rowset meta
 *
 * Note: getting version and all changes maded are in a single TxnKv transaction:
 *       step 5, 6, 7, 8
 */
void MetaServiceImpl::commit_txn(::google::protobuf::RpcController* controller,
                                 const ::selectdb::CommitTxnRequest* request,
                                 ::selectdb::CommitTxnResponse* response,
                                 ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(commit_txn);
    if (!request->has_txn_id()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "invalid argument, missing txn id";
        return;
    }

    int64_t txn_id = request->txn_id();

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "empty instance_id";
        LOG(INFO) << msg << ", cloud_unique_id=" << cloud_unique_id << " txn_id=" << txn_id;
        return;
    }

    RPC_RATE_LIMIT(commit_txn)

    // Create a readonly txn for scan tmp rowset
    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        ss << "filed to create txn, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    //Get db id with txn id
    std::string txn_index_key_;
    std::string txn_index_val;
    TxnIndexKeyInfo txn_index_key_info {instance_id, txn_id};
    txn_index_key(txn_index_key_info, &txn_index_key_);
    ret = txn->get(txn_index_key_, &txn_index_val);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        ss << "failed to get db id, txn_id=" << txn_id << " ret=" << ret;
        msg = ss.str();
        return;
    }

    TxnIndexPB txn_index_pb;
    if (!txn_index_pb.ParseFromString(txn_index_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_index_pb, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    DCHECK(txn_index_pb.has_tablet_index() == true);
    DCHECK(txn_index_pb.tablet_index().has_db_id() == true);
    int64_t db_id = txn_index_pb.tablet_index().db_id();

    // Get temporary rowsets involved in the txn
    // This is a range scan
    MetaRowsetTmpKeyInfo rs_tmp_key_info0 {instance_id, txn_id, 0};
    MetaRowsetTmpKeyInfo rs_tmp_key_info1 {instance_id, txn_id + 1, 0};
    std::string rs_tmp_key0;
    std::string rs_tmp_key1;
    meta_rowset_tmp_key(rs_tmp_key_info0, &rs_tmp_key0);
    meta_rowset_tmp_key(rs_tmp_key_info1, &rs_tmp_key1);
    // Get rowset meta that should be commited
    //                   tmp_rowset_key -> rowset_meta
    std::vector<std::pair<std::string, doris::RowsetMetaPB>> tmp_rowsets_meta;

    int num_rowsets = 0;
    std::unique_ptr<int, std::function<void(int*)>> defer_log_range(
            (int*)0x01, [rs_tmp_key0, rs_tmp_key1, &num_rowsets, &txn_id](int*) {
                LOG(INFO) << "get tmp rowset meta, txn_id=" << txn_id
                          << " num_rowsets=" << num_rowsets << " range=[" << hex(rs_tmp_key0) << ","
                          << hex(rs_tmp_key1) << ")";
            });

    std::unique_ptr<RangeGetIterator> it;
    do {
        ret = txn->get(rs_tmp_key0, rs_tmp_key1, &it);
        if (ret != 0) {
            code = MetaServiceCode::KV_TXN_GET_ERR;
            ss << "internal error, failed to get tmp rowset while committing, txn_id=" << txn_id
               << " ret=" << ret;
            msg = ss.str();
            return;
        }

        while (it->has_next()) {
            auto [k, v] = it->next();
            LOG(INFO) << "range_get rowset_tmp_key=" << hex(k) << " txn_id=" << txn_id;
            tmp_rowsets_meta.emplace_back();
            if (!tmp_rowsets_meta.back().second.ParseFromArray(v.data(), v.size())) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "malformed rowset meta, unable to initialize, txn_id=" << txn_id;
                msg = ss.str();
                ss << " key=" << hex(k);
                LOG(WARNING) << ss.str();
                return;
            }
            // Save keys that will be removed later
            tmp_rowsets_meta.back().first = std::string(k.data(), k.size());
            ++num_rowsets;
            if (!it->has_next()) rs_tmp_key0 = k;
        }
        rs_tmp_key0.push_back('\x00'); // Update to next smallest key for iteration
    } while (it->more());

    VLOG_DEBUG << "txn_id=" << txn_id << " tmp_rowsets_meta.size()=" << tmp_rowsets_meta.size();

    // Create a read/write txn for guarantee consistency
    txn.reset();
    ret = txn_kv_->create_txn(&txn);
    int64_t put_size = 0;
    int64_t del_size = 0;
    int num_put_keys = 0, num_del_keys = 0;
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        ss << "filed to create txn, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    // Get txn info with db_id and txn_id
    std::string txn_inf_key; // Will be used when saving updated txn
    std::string txn_inf_val; // Will be reused when saving updated txn
    TxnInfoKeyInfo txn_inf_key_info {instance_id, db_id, txn_id};
    txn_info_key(txn_inf_key_info, &txn_inf_key);
    ret = txn->get(txn_inf_key, &txn_inf_val);
    if (ret != 0) {
        code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND : MetaServiceCode::KV_TXN_GET_ERR;
        ss << "failed to get txn_info, db_id=" << db_id << " txn_id=" << txn_id << " ret=" << ret;
        msg = ss.str();
        return;
    }

    TxnInfoPB txn_info;
    if (!txn_info.ParseFromString(txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_info, db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    // TODO: do more check like txn state, 2PC etc.
    DCHECK(txn_info.txn_id() == txn_id);
    if (txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
        code = MetaServiceCode::TXN_ALREADY_ABORTED;
        ss << "transaction is already aborted: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    if (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE) {
        code = MetaServiceCode::TXN_ALREADY_VISIBLE;
        ss << "transaction is already visible: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        response->mutable_txn_info()->CopyFrom(txn_info);
        return;
    }

    if (request->has_is_2pc() && request->is_2pc() &&
        txn_info.status() == TxnStatusPB::TXN_STATUS_PREPARED) {
        code = MetaServiceCode::TXN_INVALID_STATUS;
        ss << "transaction is prepare, not pre-committed: db_id=" << db_id << " txn_id" << txn_id;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "txn_id=" << txn_id << " txn_info=" << txn_info.ShortDebugString();

    // Prepare rowset meta and new_versions
    std::vector<std::pair<std::string, std::string>> rowsets;
    std::map<std::string, uint64_t> new_versions;
    std::map<int64_t, TabletStats> tablet_stats; // tablet_id -> stats
    std::map<int64_t, TabletIndexPB> table_ids;  // tablet_id -> {table/index/partition}_id
    std::map<int64_t, std::vector<int64_t>> table_id_tablet_ids; // table_id -> tablets_ids
    rowsets.reserve(tmp_rowsets_meta.size());
    for (auto& [_, i] : tmp_rowsets_meta) {
        int64_t tablet_id = i.tablet_id();
        // Get version for the rowset
        if (table_ids.count(tablet_id) == 0) {
            MetaTabletIdxKeyInfo key_info {instance_id, tablet_id};
            auto [key, val] = std::make_tuple(std::string(""), std::string(""));
            meta_tablet_idx_key(key_info, &key);
            ret = txn->get(key, &val);
            if (ret != 0) { // Must be 0, an existing value
                code = MetaServiceCode::KV_TXN_GET_ERR;
                ss << "failed to get tablet table index ids,"
                   << (ret == 1 ? " not found" : " internal error") << " tablet_id=" << tablet_id
                   << " key=" << hex(key);
                msg = ss.str();
                LOG(INFO) << msg << " ret=" << ret << " txn_id=" << txn_id;
                return;
            }
            if (!table_ids[tablet_id].ParseFromString(val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "malformed tablet index value tablet_id=" << tablet_id
                   << " txn_id=" << txn_id;
                msg = ss.str();
                return;
            }
            table_id_tablet_ids[table_ids[tablet_id].table_id()].push_back(tablet_id);
            VLOG_DEBUG << "tablet_id:" << tablet_id
                       << " value:" << table_ids[tablet_id].ShortDebugString();
        }

        int64_t table_id = table_ids[tablet_id].table_id();
        int64_t partition_id = i.partition_id();

        VersionKeyInfo ver_key_info {instance_id, db_id, table_id, partition_id};
        std::string ver_key;
        version_key(ver_key_info, &ver_key);
        int64_t version = -1;
        std::string ver_val_str;
        int64_t new_version = -1;
        VersionPB version_pb;
        if (new_versions.count(ver_key) == 0) {
            ret = txn->get(ver_key, &ver_val_str);
            if (ret != 1 && ret != 0) {
                code = MetaServiceCode::KV_TXN_GET_ERR;
                ss << "failed to get version, table_id=" << table_id
                   << "partition_id=" << partition_id << " key=" << hex(ver_key);
                msg = ss.str();
                LOG(INFO) << msg << " txn_id=" << txn_id;
                return;
            }

            if (ret == 1) {
                // Maybe first version
                version = 1;
            } else {
                if (!version_pb.ParseFromString(ver_val_str)) {
                    code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                    ss << "failed to parse ver_val_str"
                       << " txn_id=" << txn_id << " key=" << hex(ver_key);
                    msg = ss.str();
                    return;
                }
                version = version_pb.version();
            }
            new_version = version + 1;
            new_versions.insert({std::move(ver_key), new_version});
        } else {
            new_version = new_versions[ver_key];
        }

        // Update rowset version
        i.set_start_version(new_version);
        i.set_end_version(new_version);

        std::string key, val;
        MetaRowsetKeyInfo key_info {instance_id, tablet_id, i.end_version()};
        meta_rowset_key(key_info, &key);
        if (!i.SerializeToString(&val)) {
            code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
            ss << "failed to serialize rowset_meta, txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        rowsets.emplace_back(std::move(key), std::move(val));

        // Accumulate affected rows
        auto& stats = tablet_stats[tablet_id];
        stats.data_size += i.data_disk_size();
        stats.num_rows += i.num_rows();
        ++stats.num_rowsets;
        stats.num_segs += i.num_segments();
    } // for tmp_rowsets_meta

    // process mow table, check lock and remove pending key
    for (auto table_id : request->mow_table_ids()) {
        std::string lock_key =
                meta_delete_bitmap_update_lock_key({instance_id, table_id, -1});
        std::string lock_val;
        ret = txn->get(lock_key, &lock_val);
        LOG(INFO) << "get delete bitmap update lock info, table_id=" << table_id
                  << " key=" << hex(lock_key) << " ret=" << ret;
        if (ret != 0) {
            ss << "failed to get delete bitmap update lock key info, instance_id=" << instance_id
               << " table_id=" << table_id << " key=" << hex(lock_key) << " ret=" << ret;
            msg = ss.str();
            code = MetaServiceCode::KV_TXN_GET_ERR;
            return;
        }
        DeleteBitmapUpdateLockPB lock_info;
        if (!lock_info.ParseFromString(lock_val)) [[unlikely]] {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            msg = "failed to parse DeleteBitmapUpdateLockPB";
            return;
        }
        if (lock_info.lock_id() != request->txn_id()) {
            msg = "lock is expired";
            code = MetaServiceCode::LOCK_EXPIRED;
            return;
        }
        txn->remove(lock_key);
        LOG(INFO) << "xxx remove delete bitmap lock, lock_key=" << hex(lock_key)
                  << " txn_id=" << txn_id;

        for (auto tablet_id : table_id_tablet_ids[table_id]) {
            std::string pending_key = meta_pending_delete_bitmap_key({instance_id, tablet_id});
            txn->remove(pending_key);
            LOG(INFO) << "xxx remove delete bitmap pending key, pending_key=" << hex(pending_key)
                      << " txn_id=" << txn_id;
        }
    }

    // Save rowset meta
    num_put_keys += rowsets.size();
    for (auto& i : rowsets) {
        size_t rowset_size = i.first.size() + i.second.size();
        txn->put(i.first, i.second);
        put_size += rowset_size;
        LOG(INFO) << "xxx put rowset_key=" << hex(i.first) << " txn_id=" << txn_id
                  << " rowset_size=" << rowset_size;
    }

    // Save versions
    num_put_keys += new_versions.size();
    for (auto& i : new_versions) {
        std::string ver_val;
        VersionPB version_pb;
        version_pb.set_version(i.second);
        if (!version_pb.SerializeToString(&ver_val)) {
            code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
            ss << "failed to serialize version_pb when saving, txn_id=" << txn_id;
            msg = ss.str();
            return;
        }

        txn->put(i.first, ver_val);
        put_size += i.first.size() + ver_val.size();
        LOG(INFO) << "xxx put version_key=" << hex(i.first) << " version:" << i.second
                  << " txn_id=" << txn_id;

        std::string_view ver_key = i.first;
        //VersionKeyInfo  {instance_id, db_id, table_id, partition_id}
        ver_key.remove_prefix(1); // Remove key space
        std::vector<std::tuple<std::variant<int64_t, std::string>, int, int>> out;
        ret = decode_key(&ver_key, &out);
        if (ret != 0) [[unlikely]] {
            // decode version key error means this is something wrong,
            // we can not continue this txn
            LOG(WARNING) << "failed to decode key, ret=" << ret << " key=" << hex(ver_key);
            code = MetaServiceCode::UNDEFINED_ERR;
            msg = "decode version key error";
            return;
        }

        int64_t table_id = std::get<int64_t>(std::get<0>(out[4]));
        int64_t partition_id = std::get<int64_t>(std::get<0>(out[5]));
        VLOG_DEBUG << " table_id=" << table_id << " partition_id=" << partition_id;

        response->add_table_ids(table_id);
        response->add_partition_ids(partition_id);
        response->add_versions(i.second);
    }

    LOG(INFO) << " before update txn_info=" << txn_info.ShortDebugString();

    // Update txn_info
    txn_info.set_status(TxnStatusPB::TXN_STATUS_VISIBLE);

    auto now_time = system_clock::now();
    uint64_t commit_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();
    if ((txn_info.prepare_time() + txn_info.timeout_ms()) < commit_time) {
        code = MetaServiceCode::UNDEFINED_ERR;
        msg = fmt::format("txn is expired, not allow to commit txn_id={}", txn_id);
        LOG(INFO) << msg << " prepare_time=" << txn_info.prepare_time()
                  << " timeout_ms=" << txn_info.timeout_ms() << " commit_time=" << commit_time;
        return;
    }
    txn_info.set_commit_time(commit_time);
    txn_info.set_finish_time(commit_time);
    if (request->has_commit_attachment()) {
        txn_info.mutable_commit_attachment()->CopyFrom(request->commit_attachment());
    }
    LOG(INFO) << "after update txn_info=" << txn_info.ShortDebugString();
    txn_inf_val.clear();
    if (!txn_info.SerializeToString(&txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_info when saving, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    txn->put(txn_inf_key, txn_inf_val);
    put_size += txn_inf_key.size() + txn_inf_val.size();
    ++num_put_keys;
    LOG(INFO) << "xxx put txn_inf_key=" << hex(txn_inf_key) << " txn_id=" << txn_id;

    // Update stats of affected tablet
    std::deque<std::string> kv_pool;
    std::function<void(const StatsTabletKeyInfo&, const TabletStats&)> update_tablet_stats;
    if (config::split_tablet_stats) {
        update_tablet_stats = [&](const StatsTabletKeyInfo& info, const TabletStats& stats) {
            if (stats.num_segs > 0) {
                auto& data_size_key = kv_pool.emplace_back();
                stats_tablet_data_size_key(info, &data_size_key);
                txn->atomic_add(data_size_key, stats.data_size);
                auto& num_rows_key = kv_pool.emplace_back();
                stats_tablet_num_rows_key(info, &num_rows_key);
                txn->atomic_add(num_rows_key, stats.num_rows);
                auto& num_segs_key = kv_pool.emplace_back();
                stats_tablet_num_segs_key(info, &num_segs_key);
                txn->atomic_add(num_segs_key, stats.num_segs);
                put_size += data_size_key.size() + num_rows_key.size() + num_segs_key.size() + 24;
                num_put_keys += 3;
            }
            auto& num_rowsets_key = kv_pool.emplace_back();
            stats_tablet_num_rowsets_key(info, &num_rowsets_key);
            txn->atomic_add(num_rowsets_key, stats.num_rowsets);
            put_size += num_rowsets_key.size() + 8;
            ++num_put_keys;
        };
    } else {
        update_tablet_stats = [&](const StatsTabletKeyInfo& info, const TabletStats& stats) {
            auto& key = kv_pool.emplace_back();
            stats_tablet_key(info, &key);
            auto& val = kv_pool.emplace_back();
            ret = txn->get(key, &val);
            if (ret != 0) {
                code = ret == 1 ? MetaServiceCode::TABLET_NOT_FOUND
                                : MetaServiceCode::KV_TXN_GET_ERR;
                msg = fmt::format("failed to get tablet stats, ret={} tablet_id={}", ret,
                                  std::get<4>(info));
                return;
            }
            TabletStatsPB stats_pb;
            if (!stats_pb.ParseFromString(val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                msg = fmt::format("malformed tablet stats value, key={}", hex(key));
                return;
            }
            stats_pb.set_data_size(stats_pb.data_size() + stats.data_size);
            stats_pb.set_num_rows(stats_pb.num_rows() + stats.num_rows);
            stats_pb.set_num_rowsets(stats_pb.num_rowsets() + stats.num_rowsets);
            stats_pb.set_num_segments(stats_pb.num_segments() + stats.num_segs);
            stats_pb.SerializeToString(&val);
            txn->put(key, val);
            put_size += key.size() + val.size();
            ++num_put_keys;
        };
    }
    for (auto& [tablet_id, stats] : tablet_stats) {
        DCHECK(table_ids.count(tablet_id));
        auto& tablet_idx = table_ids[tablet_id];
        StatsTabletKeyInfo info {instance_id, tablet_idx.table_id(), tablet_idx.index_id(),
                                 tablet_idx.partition_id(), tablet_id};
        update_tablet_stats(info, stats);
        if (code != MetaServiceCode::OK) return;
    }
    // Remove tmp rowset meta
    num_del_keys += tmp_rowsets_meta.size();
    for (auto& [k, _] : tmp_rowsets_meta) {
        txn->remove(k);
        del_size += k.size();
        LOG(INFO) << "xxx remove tmp_rowset_key=" << hex(k) << " txn_id=" << txn_id;
    }

    std::string txn_run_key;
    TxnRunningKeyInfo txn_run_key_info {instance_id, db_id, txn_id};
    txn_running_key(txn_run_key_info, &txn_run_key);
    LOG(INFO) << "xxx remove txn_run_key=" << hex(txn_run_key) << " txn_id=" << txn_id;
    txn->remove(txn_run_key);
    del_size += txn_run_key.size();
    ++num_del_keys;

    std::string recycle_txn_key_;
    std::string recycle_txn_val;
    RecycleTxnKeyInfo recycle_txn_key_info {instance_id, db_id, txn_id};

    recycle_txn_key(recycle_txn_key_info, &recycle_txn_key_);
    RecycleTxnPB recycle_txn_pb;
    recycle_txn_pb.set_creation_time(commit_time);
    recycle_txn_pb.set_label(txn_info.label());

    if (!recycle_txn_pb.SerializeToString(&recycle_txn_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize running_val_pb, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    txn->put(recycle_txn_key_, recycle_txn_val);
    put_size += recycle_txn_key_.size() + recycle_txn_val.size();
    ++num_put_keys;

    if (txn_info.load_job_source_type() ==
        LoadJobSourceTypePB::LOAD_JOB_SRC_TYPE_ROUTINE_LOAD_TASK) {
        if (!request->has_commit_attachment()) {
            ss << "failed to get commit attachment from req, db_id=" << db_id
               << " txn_id=" << txn_id;
            msg = ss.str();
            return;
        }

        TxnCommitAttachmentPB txn_commit_attachment = request->commit_attachment();
        RLTaskTxnCommitAttachmentPB commit_attachment =
                txn_commit_attachment.rl_task_txn_commit_attachment();
        int64_t job_id = commit_attachment.job_id();

        std::string rl_progress_key;
        std::string rl_progress_val;
        bool prev_progress_existed = true;
        RLJobProgressKeyInfo rl_progress_key_info {instance_id, db_id, job_id};
        rl_job_progress_key_info(rl_progress_key_info, &rl_progress_key);
        ret = txn->get(rl_progress_key, &rl_progress_val);
        if (ret != 0) {
            if (ret > 0) {
                prev_progress_existed = false;
            } else {
                code = MetaServiceCode::KV_TXN_GET_ERR;
                ss << "failed to get txn_info, db_id=" << db_id << " txn_id=" << txn_id
                   << " ret=" << ret;
                msg = ss.str();
                return;
            }
        }

        RoutineLoadProgressPB prev_progress_info;
        if (prev_progress_existed) {
            if (!prev_progress_info.ParseFromString(rl_progress_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "failed to parse txn_info, db_id=" << db_id << " txn_id=" << txn_id;
                msg = ss.str();
                return;
            }

            int cal_row_num = 0;
            for (auto const& elem : commit_attachment.progress().partition_to_offset()) {
                if (elem.second >= 0) {
                    auto it = prev_progress_info.partition_to_offset().find(elem.first);
                    if (it != prev_progress_info.partition_to_offset().end() && it->second >= 0) {
                        cal_row_num += elem.second - it->second;
                    } else {
                        cal_row_num += elem.second + 1;
                    }
                }
            }

            LOG(INFO) << " caculated row num " << cal_row_num << " actual row num "
                      << commit_attachment.loaded_rows() << " prev prgress "
                      << prev_progress_info.DebugString();

            if (cal_row_num != commit_attachment.loaded_rows()) {
                if (cal_row_num == 0) {
                    LOG(WARNING) << " repeated to load task in routine load, db_id=" << db_id
                                 << " txn_id=" << txn_id << " caculated row num " << cal_row_num
                                 << " actual row num " << commit_attachment.loaded_rows();
                    return;
                }

                code = MetaServiceCode::ROUTINE_LOAD_DATA_INCONSISTENT;
                ss << " repeated to load task in routine load, db_id=" << db_id
                   << " txn_id=" << txn_id << " caculated row num " << cal_row_num
                   << " actual row num " << commit_attachment.loaded_rows();
                msg = ss.str();
                return;
            }
        }

        std::string new_progress_val;
        RoutineLoadProgressPB new_progress_info;
        new_progress_info.CopyFrom(commit_attachment.progress());
        for (auto const& elem : prev_progress_info.partition_to_offset()) {
            auto it = new_progress_info.partition_to_offset().find(elem.first);
            if (it == new_progress_info.partition_to_offset().end()) {
                new_progress_info.mutable_partition_to_offset()->insert(elem);
            }
        }

        if (!new_progress_info.SerializeToString(&new_progress_val)) {
            code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
            ss << "failed to serialize new progress val, txn_id=" << txn_info.txn_id();
            msg = ss.str();
            return;
        }
        txn->put(rl_progress_key, new_progress_val);
    }

    LOG(INFO) << "xxx commit_txn put recycle_txn_key key=" << hex(recycle_txn_key_)
              << " txn_id=" << txn_id;
    LOG(INFO) << "commit_txn put_size=" << put_size << " del_size=" << del_size
              << " num_put_keys=" << num_put_keys << " num_del_keys=" << num_del_keys
              << " txn_id=" << txn_id;

    // Finally we are done...
    ret = txn->commit();
    if (ret != 0) {
        code = ret == -1 ? MetaServiceCode::KV_TXN_CONFLICT : MetaServiceCode::KV_TXN_COMMIT_ERR;
        ss << "failed to commit kv txn, txn_id=" << txn_id << " ret=" << ret;
        msg = ss.str();
        return;
    }
    response->mutable_txn_info()->CopyFrom(txn_info);
} // end commit_txn

void MetaServiceImpl::abort_txn(::google::protobuf::RpcController* controller,
                                const ::selectdb::AbortTxnRequest* request,
                                ::selectdb::AbortTxnResponse* response,
                                ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(abort_txn);
    // Get txn id
    int64_t txn_id = request->has_txn_id() ? request->txn_id() : -1;
    std::string label = request->has_label() ? request->label() : "";
    int64_t db_id = request->has_db_id() ? request->db_id() : -1;
    if (txn_id < 0 && (label.empty() || db_id < 0)) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "invalid txn id and label, db_id=" << db_id << " txn_id=" << txn_id
           << " label=" << label;
        msg = ss.str();
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, request->cloud_unique_id());
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id) << " label=" << label
           << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    RPC_RATE_LIMIT(abort_txn);
    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        ss << "filed to txn_kv_->create_txn(), txn_id=" << txn_id << " label=" << label;
        msg = ss.str();
        return;
    }

    std::string txn_inf_key; // Will be used when saving updated txn
    std::string txn_inf_val; // Will be reused when saving updated txn
    TxnInfoPB txn_info;

    //TODO: split with two function.
    //there two ways to abort txn:
    //1. abort txn by txn id
    //2. abort txn by label and db_id
    if (txn_id > 0) {
        VLOG_DEBUG << "abort_txn by txn_id";
        //abort txn by txn id
        // Get db id with txn id

        std::string txn_index_key_;
        std::string txn_index_val;

        //not provide db_id, we need read from disk.
        if (!request->has_db_id()) {
            TxnIndexKeyInfo txn_index_key_info {instance_id, txn_id};
            txn_index_key(txn_index_key_info, &txn_index_key_);
            ret = txn->get(txn_index_key_, &txn_index_val);
            if (ret != 0) {
                code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND
                               : MetaServiceCode::KV_TXN_GET_ERR;
                ss << "failed to get db id, txn_id=" << txn_id << " ret=" << ret;
                msg = ss.str();
                return;
            }

            TxnIndexPB txn_index_pb;
            if (!txn_index_pb.ParseFromString(txn_index_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "failed to parse txn_index_val"
                   << " txn_id=" << txn_id;
                msg = ss.str();
                return;
            }
            DCHECK(txn_index_pb.has_tablet_index() == true);
            DCHECK(txn_index_pb.tablet_index().has_db_id() == true);
            db_id = txn_index_pb.tablet_index().db_id();
        } else {
            db_id = request->db_id();
        }

        // Get txn info with db_id and txn_id
        TxnInfoKeyInfo txn_inf_key_info {instance_id, db_id, txn_id};
        txn_info_key(txn_inf_key_info, &txn_inf_key);
        ret = txn->get(txn_inf_key, &txn_inf_val);
        if (ret != 0) {
            code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND : MetaServiceCode::KV_TXN_GET_ERR;
            ss << "failed to get txn_info, db_id=" << db_id << "txn_id=" << txn_id << "ret=" << ret;
            msg = ss.str();
            return;
        }

        if (!txn_info.ParseFromString(txn_inf_val)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "failed to parse txn_info db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }

        DCHECK(txn_info.txn_id() == txn_id);

        //check state is valid.
        if (txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
            code = MetaServiceCode::TXN_ALREADY_ABORTED;
            ss << "transaction is already abort db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        if (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE) {
            code = MetaServiceCode::TXN_ALREADY_VISIBLE;
            ss << "transaction is already visible db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
    } else {
        VLOG_DEBUG << "abort_txn by db_id and txn label";
        //abort txn by label.
        std::string txn_label_key_;
        std::string txn_label_val;

        TxnLabelKeyInfo txn_label_key_info {instance_id, db_id, label};
        txn_label_key(txn_label_key_info, &txn_label_key_);
        ret = txn->get(txn_label_key_, &txn_label_val);
        if (ret < 0) {
            code = MetaServiceCode::KV_TXN_GET_ERR;
            ss << "txn->get() failed, label=" << label << " ret=" << ret;
            msg = ss.str();
            return;
        }
        //label index not exist
        if (ret > 0) {
            code = MetaServiceCode::TXN_LABEL_NOT_FOUND;
            ss << "label not found, db_id=" << db_id << " label=" << label << " ret=" << ret;
            msg = ss.str();
            return;
        }

        TxnLabelPB txn_label_pb;
        DCHECK(txn_label_val.size() > 10);
        std::string txn_label_pb_str = txn_label_val.substr(0, txn_label_val.size() - 10);
        if (!txn_label_pb.ParseFromString(txn_label_pb_str)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "txn_label_pb->ParseFromString() failed, label=" << label;
            msg = ss.str();
            return;
        }

        int64_t prepare_txn_id = 0;
        //found prepare state txn for abort
        for (auto& cur_txn_id : txn_label_pb.txn_ids()) {
            std::string cur_txn_inf_key;
            std::string cur_txn_inf_val;
            TxnInfoKeyInfo cur_txn_inf_key_info {instance_id, db_id, cur_txn_id};
            txn_info_key(cur_txn_inf_key_info, &cur_txn_inf_key);
            ret = txn->get(cur_txn_inf_key, &cur_txn_inf_val);
            if (ret != 0) {
                code = MetaServiceCode::KV_TXN_GET_ERR;
                std::stringstream ss;
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " ret=" << ret;
                msg = ss.str();
                return;
            }
            // ret == 0
            TxnInfoPB cur_txn_info;
            if (!cur_txn_info.ParseFromString(cur_txn_inf_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                std::stringstream ss;
                ss << "cur_txn_info->ParseFromString() failed, cur_txn_id=" << cur_txn_id;
                msg = ss.str();
                return;
            }
            VLOG_DEBUG << "cur_txn_info=" << cur_txn_info.ShortDebugString();
            //TODO: 2pc alse need to check TxnStatusPB::TXN_STATUS_PRECOMMITTED
            if ((cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PREPARED) ||
                (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PRECOMMITTED)) {
                prepare_txn_id = cur_txn_id;
                txn_info = std::move(cur_txn_info);
                txn_inf_key = std::move(cur_txn_inf_key);
                DCHECK_EQ(prepare_txn_id, txn_info.txn_id())
                        << "prepare_txn_id=" << prepare_txn_id << " txn_id=" << txn_info.txn_id();
                break;
            }
        }

        if (prepare_txn_id == 0) {
            code = MetaServiceCode::TXN_INVALID_STATUS;
            std::stringstream ss;
            ss << "running transaction not found, db_id=" << db_id << " label=" << label;
            msg = ss.str();
            return;
        }
    }

    auto now_time = system_clock::now();
    uint64_t finish_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();

    // Update txn_info
    txn_info.set_status(TxnStatusPB::TXN_STATUS_ABORTED);
    txn_info.set_finish_time(finish_time);
    request->has_reason() ? txn_info.set_reason(request->reason())
                          : txn_info.set_reason("User Abort");

    if (request->has_commit_attachment()) {
        TxnCommitAttachmentPB attachement = request->commit_attachment();
        txn_info.mutable_commit_attachment()->CopyFrom(request->commit_attachment());
    }

    txn_inf_val.clear();
    if (!txn_info.SerializeToString(&txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_info when saving, txn_id=" << txn_info.txn_id();
        msg = ss.str();
        return;
    }
    LOG(INFO) << "check watermark conflict, txn_info=" << txn_info.ShortDebugString();
    txn->put(txn_inf_key, txn_inf_val);
    LOG(INFO) << "xxx put txn_inf_key=" << hex(txn_inf_key) << " txn_id=" << txn_info.txn_id();

    std::string txn_run_key;
    TxnRunningKeyInfo txn_run_key_info {instance_id, db_id, txn_info.txn_id()};
    txn_running_key(txn_run_key_info, &txn_run_key);
    txn->remove(txn_run_key);
    LOG(INFO) << "xxx remove txn_run_key=" << hex(txn_run_key) << " txn_id=" << txn_info.txn_id();

    std::string recycle_txn_key_;
    std::string recycle_txn_val;
    RecycleTxnKeyInfo recycle_txn_key_info {instance_id, db_id, txn_info.txn_id()};
    recycle_txn_key(recycle_txn_key_info, &recycle_txn_key_);
    RecycleTxnPB recycle_txn_pb;
    recycle_txn_pb.set_creation_time(finish_time);
    recycle_txn_pb.set_label(txn_info.label());

    if (!recycle_txn_pb.SerializeToString(&recycle_txn_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize running_val_pb, txn_id=" << txn_info.txn_id();
        msg = ss.str();
        return;
    }
    txn->put(recycle_txn_key_, recycle_txn_val);
    LOG(INFO) << "xxx put recycle_txn_key=" << hex(recycle_txn_key_)
              << " txn_id=" << txn_info.txn_id();

    ret = txn->commit();
    if (ret != 0) {
        code = ret == -1 ? MetaServiceCode::KV_TXN_CONFLICT : MetaServiceCode::KV_TXN_COMMIT_ERR;
        ss << "failed to commit kv txn, txn_id=" << txn_info.txn_id() << " ret=" << ret;
        msg = ss.str();
        return;
    }
    response->mutable_txn_info()->CopyFrom(txn_info);
}

void MetaServiceImpl::get_txn(::google::protobuf::RpcController* controller,
                              const ::selectdb::GetTxnRequest* request,
                              ::selectdb::GetTxnResponse* response,
                              ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(get_txn);
    int64_t txn_id = request->has_txn_id() ? request->txn_id() : -1;
    int64_t db_id = request->has_db_id() ? request->db_id() : -1;
    if (txn_id < 0) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "invalid txn_id, it may be not given or set properly, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id);
        msg = ss.str();
        return;
    }

    RPC_RATE_LIMIT(get_txn)
    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        ss << "failed to create txn, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    //not provide db_id, we need read from disk.
    if (db_id < 0) {
        std::string txn_index_key_;
        std::string txn_index_val;
        TxnIndexKeyInfo txn_index_key_info {instance_id, txn_id};
        txn_index_key(txn_index_key_info, &txn_index_key_);
        ret = txn->get(txn_index_key_, &txn_index_val);
        if (ret != 0) {
            code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND : MetaServiceCode::KV_TXN_GET_ERR;
            ss << "failed to get db id with txn_id=" << txn_id << " ret=" << ret;
            msg = ss.str();
            return;
        }

        TxnIndexPB txn_index_pb;
        if (!txn_index_pb.ParseFromString(txn_index_val)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "failed to parse txn_inf"
               << " txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        DCHECK(txn_index_pb.has_tablet_index() == true);
        DCHECK(txn_index_pb.tablet_index().has_db_id() == true);
        db_id = txn_index_pb.tablet_index().db_id();
        if (db_id <= 0) {
            ss << "internal error: unexpected db_id " << db_id;
            code = MetaServiceCode::UNDEFINED_ERR;
            msg = ss.str();
            return;
        }
    }

    // Get txn info with db_id and txn_id
    std::string txn_inf_key; // Will be used when saving updated txn
    std::string txn_inf_val; // Will be reused when saving updated txn
    TxnInfoKeyInfo txn_inf_key_info {instance_id, db_id, txn_id};
    txn_info_key(txn_inf_key_info, &txn_inf_key);
    ret = txn->get(txn_inf_key, &txn_inf_val);
    if (ret != 0) {
        code = ret > 0 ? MetaServiceCode::TXN_ID_NOT_FOUND : MetaServiceCode::KV_TXN_GET_ERR;
        ss << "failed to get db id with db_id=" << db_id << " txn_id=" << txn_id << " ret=" << ret;
        msg = ss.str();
        return;
    }

    TxnInfoPB txn_info;
    if (!txn_info.ParseFromString(txn_inf_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_inf db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    VLOG_DEBUG << "txn_info=" << txn_info.ShortDebugString();
    DCHECK(txn_info.txn_id() == txn_id);
    response->mutable_txn_info()->CopyFrom(txn_info);
}

//To get current max txn id for schema change watermark etc.
void MetaServiceImpl::get_current_max_txn_id(::google::protobuf::RpcController* controller,
                                             const ::selectdb::GetCurrentMaxTxnRequest* request,
                                             ::selectdb::GetCurrentMaxTxnResponse* response,
                                             ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(get_current_max_txn_id);
    // TODO: For auth
    instance_id = get_instance_id(resource_mgr_, request->cloud_unique_id());
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "empty instance_id";
        LOG(INFO) << msg << ", cloud_unique_id=" << request->cloud_unique_id();
        return;
    }
    RPC_RATE_LIMIT(get_current_max_txn_id)
    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        msg = "failed to create txn";
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        return;
    }

    std::string key = "schema change";
    std::string val;
    ret = txn->get(key, &val);
    if (ret < 0) {
        code = MetaServiceCode::KV_TXN_GET_ERR;
        std::stringstream ss;
        ss << "txn->get() failed,"
           << " ret=" << ret;
        msg = ss.str();
        return;
    }
    int64_t read_version = txn->get_read_version();
    int64_t current_max_txn_id = read_version << 10;
    VLOG_DEBUG << "read_version=" << read_version << " current_max_txn_id=" << current_max_txn_id;
    response->set_current_max_txn_id(current_max_txn_id);
}

void MetaServiceImpl::check_txn_conflict(::google::protobuf::RpcController* controller,
                                         const ::selectdb::CheckTxnConflictRequest* request,
                                         ::selectdb::CheckTxnConflictResponse* response,
                                         ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(check_txn_conflict);
    if (!request->has_db_id() || !request->has_end_txn_id() || (request->table_ids_size() <= 0)) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "invalid db id, end txn id or table_ids.";
        return;
    }
    // TODO: For auth
    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id);
        msg = ss.str();
        return;
    }
    RPC_RATE_LIMIT(check_txn_conflict)
    int64_t db_id = request->db_id();
    std::string begin_txn_run_key;
    std::string begin_txn_run_val;
    std::string end_txn_run_key;
    std::string end_txn_run_val;
    TxnRunningKeyInfo begin_txn_run_key_info {instance_id, db_id, 0};
    TxnRunningKeyInfo end_txn_run_key_info {instance_id, db_id, request->end_txn_id()};
    txn_running_key(begin_txn_run_key_info, &begin_txn_run_key);
    txn_running_key(end_txn_run_key_info, &end_txn_run_key);
    LOG(INFO) << "begin_txn_run_key:" << hex(begin_txn_run_key)
              << " end_txn_run_key:" << hex(end_txn_run_key);

    std::unique_ptr<Transaction> txn;
    ret = txn_kv_->create_txn(&txn);
    if (ret != 0) {
        msg = "failed to create txn";
        code = MetaServiceCode::KV_TXN_CREATE_ERR;
        return;
    }

    //TODO: use set to replace
    std::vector<int64_t> src_table_ids(request->table_ids().begin(), request->table_ids().end());
    std::sort(src_table_ids.begin(), src_table_ids.end());
    std::unique_ptr<RangeGetIterator> it;
    int64_t skip_timeout_txn_cnt = 0;
    int total_iteration_cnt = 0;
    do {
        ret = txn->get(begin_txn_run_key, end_txn_run_key, &it, true);
        if (ret != 0) {
            code = MetaServiceCode::KV_TXN_GET_ERR;
            ss << "failed to get txn running info. ret=" << ret;
            msg = ss.str();
            LOG(WARNING) << msg;
            return;
        }

        VLOG_DEBUG << "begin_txn_run_key=" << hex(begin_txn_run_key)
                   << " end_txn_run_val=" << hex(end_txn_run_val)
                   << " it->has_next()=" << it->has_next();

        auto now_time = system_clock::now();
        uint64_t check_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();
        while (it->has_next()) {
            total_iteration_cnt++;
            auto [k, v] = it->next();
            LOG(INFO) << "check watermark conflict range_get txn_run_key=" << hex(k);
            TxnRunningPB running_val_pb;
            if (!running_val_pb.ParseFromArray(v.data(), v.size())) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "malformed txn running info";
                msg = ss.str();
                ss << " key=" << hex(k);
                LOG(WARNING) << ss.str();
                return;
            }

            if (running_val_pb.timeout_time() < check_time) {
                skip_timeout_txn_cnt++;
                break;
            }

            LOG(INFO) << "check watermark conflict range_get txn_run_key=" << hex(k)
                      << " running_val_pb=" << running_val_pb.ShortDebugString();
            std::vector<int64_t> running_table_ids(running_val_pb.table_ids().begin(),
                                                   running_val_pb.table_ids().end());
            std::sort(running_table_ids.begin(), running_table_ids.end());
            std::vector<int64_t> result(std::min(running_table_ids.size(), src_table_ids.size()));
            std::vector<int64_t>::iterator iter = std::set_intersection(
                    src_table_ids.begin(), src_table_ids.end(), running_table_ids.begin(),
                    running_table_ids.end(), result.begin());
            result.resize(iter - result.begin());
            if (result.size() > 0) {
                response->set_finished(false);
                LOG(INFO) << "skip timeout txn count: " << skip_timeout_txn_cnt
                          << " total iteration count: " << total_iteration_cnt;
                return;
            }

            if (!it->has_next()) {
                begin_txn_run_key = k;
            }
        }
        begin_txn_run_key.push_back('\x00'); // Update to next smallest key for iteration
    } while (it->more());
    LOG(INFO) << "skip timeout txn count: " << skip_timeout_txn_cnt
              << " total iteration count: " << total_iteration_cnt;
    response->set_finished(true);
}

} // namespace selectdb
